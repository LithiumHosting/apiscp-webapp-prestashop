<?php

use LithiumHosting\WebApps\PrestaShop\Handler;
use Module\Support\Webapps;
use Module\Support\Webapps\DatabaseGenerator;
use Module\Support\Webapps\PhpWrapper;
use Module\Support\Webapps\VersionFetcher\Github;
use Opcenter\Auth\Password;
use Opcenter\Versioning;

/**
 * Web application management
 *
 * @package core
 */
class PrestaShop_Module extends Webapps
{
	const APP_NAME             = Handler::NAME;
	const DEFAULT_VERSION_LOCK = 'minor';

	protected $aclList = [
		'min' => [
			'config',
			'cache',
			'download',
			'img',
			'log',
			'mails',
			'modules',
			'override',
			'themes/default/lang',
			'themes/default/pdf/lang',
			'themes/default/cache',
			'translations',
			'upload',
			'sitemap.xml',
		],
		'max' => [
			'config',
			'cache',
			'download',
			'img',
			'log',
			'mails',
			'modules',
			'override',
			'themes/default/lang',
			'themes/default/pdf/lang',
			'themes/default/cache',
			'translations',
			'upload',
			'sitemap.xml',
		],
	];

	/**
	 * Install application
	 *
	 * @param  string  $hostname  domain or subdomain to install application
	 * @param  string  $path      optional path under hostname
	 * @param  array   $opts      additional install options
	 *
	 * @return bool
	 */
	public function install(string $hostname, string $path = '', array $opts = []): bool {
		if (! version_compare($this->php_version(), '7', '>=')) {
			return error('PrestaShop requires PHP8 or higher.');
		}

		if (! $this->parseInstallOptions($opts, $hostname, $path)) {
			return false;
		}

		if (! ($docroot = $this->getDocumentRoot($hostname, $path))) {
			return error("failed to normalize path for `%s'", $hostname);
		}

		$args['version'] = $opts['version'];

		if (! isset($opts['shopname'])) {
			$opts['shopname'] = 'Presta Shop';
			info("setting shopname to default of `%s'", $opts['sitename']);
		}

		$opts['adminpassword'] = Password::generate();
		info("autogenerated password `%s'", $opts['adminpassword']);
		$opts['email'] ?? $this->common_get_email();

		$oldex = Error_Reporter::exception_upgrade(Error_Reporter::E_ERROR);
		$approot = $this->getAppRoot($hostname, $path);

		try {
			$this->downloadPackage($approot, $args['version']);

			$db = DatabaseGenerator::mysql($this->getAuthContext(), $hostname);
			$db->connectionLimit = max($db->connectionLimit, 15);
			if (! $db->create()) {
				return false;
			}

			$installArgs = [
				'domain'   => $hostname,
				'email'    => $opts['email'],
				'passwd'   => $opts['adminpassword'],
				'server'   => $opts['ssl'] ? "https://$hostname/" : "http://$hostname/",
				'dbserver' => $db->hostname,
				'dbuser'   => $db->username,
				'dbpass'   => $db->password,
				'dbname'   => $db->database,
				'shopname' => $opts['shopname'],
				'ssl'      => $opts['ssl'] ? 1 : 0,
			];

			$installCommand = 'index_cli.php '.
				'--domain %(domain)s '.
				'--email %(email)s '.
				'--password %(passwd)s '.
				'--http_server %(server)s '.
				'--engine InnoDB '.
				'--db_server %(dbserver)s '.
				'--db_user %(dbuser)s '.
				'--db_password %(dbpass)s '.
				'--db_name %(dbname)s '.
				'--prefix "" '.
				'--name %(shopname)s '.
				'--ssl %(ssl)s '.
				'--newsletter 0 '.
				'--send_email 1';

			$ret = PhpWrapper::instantiateContexted($this->getAuthContextFromDocroot($approot))->exec("$approot/install", $installCommand, $installArgs);

			dd($ret);

			if (! $ret['success']) {
				return error("failed to install %(app)s: %(err)s", [
					'app'     => static::APP_NAME,
					'approot' => $approot,
					'err'     => $ret['stderr']
				]);
			}
		} catch (apnscpException $e) {
			$this->file_delete("$approot/", true);
			if (isset($db)) {
				$db->rollback();
			}

			return error('Failed to install %s: %s', static::APP_NAME, $e->getMessage());
		} finally {
			Error_Reporter::exception_upgrade($oldex);
		}

		$this->initializeMeta($docroot, $opts);

		$this->fortify($hostname, $path, Handler::DEFAULT_FORTIFICATION);
		$this->notifyInstalled($hostname, $path, $opts);

		return info('%(app)s installed - confirmation email with login info sent to %(email)s',
			['app' => static::APP_NAME, 'email' => $opts['email']]);;
	}

	/**
	 * Get all available versions sorted in ascending semantic version
	 *
	 * @return array
	 */
	public function get_versions(): array {
		$versions = $this->_getVersions();

		return array_column(array_filter($versions, static function($meta) {
			return false === strpos($meta['version'], '-');
		}), 'version');
	}

	/**
	 * Get installed version
	 *
	 * @param  string  $hostname
	 * @param  string  $path
	 *
	 * @return string|null|bool version number, null if not app or false on failure
	 */
	public function get_version(string $hostname, string $path = ''): ?string {
		// TODO: Implement get_version() method.
		$approot = $this->getAppRoot($hostname, $path);

		if (! $this->valid($hostname, $path)) {
			return null;
		}

		return '1.0.0.0';
	}

	/**
	 * Get all current major versions
	 *
	 * @return array
	 */
	private function _getVersions(): array {
		$key = 'prestashop.versions';
		$cache = Cache_Super_Global::spawn();
		if (false !== ($ver = $cache->get($key))) {
			return (array) $ver;
		}
		$versions = (new Github)->fetch('prestashop/prestashop');

		$cache->set($key, $versions, 43200);

		return $versions;
	}

	/**
	 * Location is a valid webapp install
	 *
	 * @param  string  $hostname  or $docroot
	 * @param  string  $path
	 *
	 * @return bool
	 */
	public function valid(string $hostname, string $path = ''): bool {
		if ($hostname[0] === '/') {
			$approot = $hostname;
		} else {
			$approot = $this->getAppRoot($hostname, $path);
			if (! $approot) {
				return false;
			}
		}
		return $this->file_exists($approot.'/src/PrestaShopBundle/PrestaShopBundle.php');
	}

	/**
	 * Update core, plugins, and themes atomically
	 *
	 * @param  string  $hostname  subdomain or domain
	 * @param  string  $path      optional path under hostname
	 * @param  string  $version
	 *
	 * @return bool
	 */
	public function update_all(string $hostname, string $path = '', string $version = null): bool {
		return $this->update($hostname, $path, $version);
	}

	/**
	 * Update application to latest version
	 *
	 * @param  string  $hostname  domain or subdomain under which application is installed
	 * @param  string  $path      optional subdirectory
	 * @param  string  $version
	 *
	 * @return bool
	 */
	public function update(string $hostname, string $path = '', string $version = null): bool {
		// TODO: Implement update() method.
	}

	/**
	 * Download remote MediaWiki version and Extract into directory
	 *
	 * @param  string  $approot
	 * @param  string  $version
	 *
	 * @return bool
	 */
	private function downloadPackage(string $approot, string $version): bool {
		$minor = Versioning::asMinor($version);

		$this->download("https://download.prestashop.com/download/releases/prestashop_$version.zip", $approot);
		return $this->file_extract("$approot/prestashop.zip", $approot) && $this->file_delete("$approot/prestashop.zip");
	}

	/**
	 * Get database configuration for application
	 *
	 * @param  string  $hostname  domain or subdomain of wp blog
	 * @param  string  $path      optional path
	 *
	 * @return bool|array
	 */
//	public function db_config(string $hostname, string $path = '')
//	{
//		$approot = $this->getAppRoot($hostname, $path);
//		if (! $this->file_exists($approot.'/LocalSettings.php')) {
//			return false;
//		}
//
//		$code = 'ob_start(); include("./LocalSettings.php"); file_put_contents("php://fd/3", serialize(["db" => $wgDBname, "user" => $wgDBuser, "host" => $wgDBserver, "prefix" => $wgDBprefix, "password" =>  $wgDBpassword])); ';
//		$cmd = 'cd %(path)s && php -d mysqli.default_socket=%(socket)s -r %(code)s 3>&1-';
//		$ret = $this->pman_run($cmd, [
//			'path'   => $approot,
//			'code'   => $code,
//			'socket' => ini_get('mysqli.default_socket')
//		]);
//
//		if (! $ret['success']) {
//			return error("failed to obtain %(app)s configuration for `%(approot)s': %(err)s", [
//				'app'     => static::APP_NAME,
//				'approot' => $approot,
//				'err'     => $ret['stderr']
//			]);
//		}
//
//		return \Util_PHP::unserialize(trim($ret['stdout']));
//	}
}